---
title: "SQLD 16 옵티마이저와 실행계획"
date: 2020-07-27T21:31:05+09:00
categories:
- SQLD
- 2과목 SQL 기본 및 활용
tags:
- SQLD
keywords:
- SQLD
---

<!--more-->

# 옵티마이저와 실행계획

&nbsp;

## 1.옵티마이저

**옵티마이저(Optimizer)** : 사용자가 질의한 SQL문에 대해 최적의 실행 방법을 결정하는 역할 수행.   
**실행계획(Execution Plan)** : 최적의 실행 방법.   

**종류**   
- 규칙기반 옵티마이저 (RBO, Rule Based Optimizer)
- 비용기반 옵티마이저 (CBO, Cost Based Optimizer)

![SQL_239](https://user-images.githubusercontent.com/28701069/88542414-59752800-d051-11ea-82c7-943d9de0cb4c.jpg)

&nbsp;

-----

- **규칙기반 옵티마이저**

규칙(우선 순위)를 가지고 실행계획을 세운다. 우선 순위가 높은 규칙이 적은 일량으로 해당 작업을 수행하는 방법이라고 판단하는 것이다.   

순위의 숫자가 낮을수록 높은 우선순위이다.

![SQL_240](https://user-images.githubusercontent.com/28701069/88542699-c8eb1780-d051-11ea-9de0-df9d5b889b9c.jpg)


**주요규칙**

1. Single row by rowid : ROWID를 통해서 테이블에서 하나의 행을 액세스하는 방식이다. ROWID는 행이 포함된 데이터 파일, 블록 등의 정보를 가지고 있기 때문에 다른 정보를 참조하지 않고도 바로 원하는 행을 액세스할 수 있다.   

4. Single row by unique or primary key : 유일 인덱스를 통한 방식. 인덱스를 먼저 액세스하고 인덱스에 존재하는 ROWID를 추출하여 테이블의 행을 액세스한다.   

8. Composite index : 복합 인덱스에 동등('=' 연산자) 조건으로 검색하는 경우. 인덱스 구성 칼럼의 개수가 더 많고 해당 인덱스의 모든 구성 칼럼에 대해 '='로 값이 주어질 수록 우선순위가 더 높다.   

9. Single Column index : 단일 칼럼 인덱스에 '='로 검색하는 경우.   

10. Bounded range search on indexed columns : 인덱스가 생성되어있는 칼럼에 양쪽 범위를 한정하는 형태로 검색하는 방식. BETWEEN, LIKE등이 있다.   

11. Unbounded range search on indexed columns : 인덱스가 생성되어있는 칼럼에 한쪽 범위만 한정하는 형태로 검색. >, <, >=, <= 등이 있다.   

15. Full table Scan : 전체 테이블을 액세스하면서 조건절에 주어진 조건을 만족하는 행 추출.   

&nbsp;

규칙기반 옵티마이저가 조인 순서를 결정할 때는 조인 칼럼 인덱스의 존재 유무가 중요한 판단의 기준이다.    
조인 칼럼에 대한 인덱스가 양쪽 테이블에 모두 존재한다면 규칙 우선순위가 높은 테이블을 선행 테이블(Driving Table)로 선택한다.   
한쪽 조인 칼럼에만 인덱스가 존재하는 경우에는 인덱스가 없는 테이블을 선행테이블로 선택한다.   
만약 조인칼럼에 모두 인덱스가 존재하지 않으면 FROM절에 나열된 테이블을 선행 테이블로 선택한다.   
만약 조인 테이블의 우선순위가 동일하다면 FROM절에 나열된 테이블의 역순으로 선행 테이블을 선택한다.   

조인기법 선택은 다음과 같다.   
- Sort Merge Join : 양쪽 조인 칼럼에 모두 인덱스가 없는 경우   
- NL Join :  둘 중 하나라도 조인 칼럼에 인덱스가 존재하는 경우   

&nbsp;

-----

&nbsp;

- **비용기반 옵티마이저**   

규칙기반 옵티마이저의 단점을 극복하기 위하여 출현하였다.   
비용을 예측하기 위해 사용하지 않는 테이블, 인덱스, 칼럼 등의 다양한 객체 통계정보와 시스템 통계정보 등을 이용한다. 통계정보가 없는 경우는 정확한 예측이 불가능해져서 비효율적인 실행계획을 생성할 수 있다. -> 정확한 통계정보를 유지하는 것은 비용기반 최적화에서 중요한 요소다.   
실행계획의 예측 및 제어가 어렵다는 단점이 있다.

![SQL_241](https://user-images.githubusercontent.com/28701069/88545380-de624080-d055-11ea-88b2-6efb17dd2d62.jpg)

&nbsp;

- **질의 변환기**   
사용자가 작성한 쿼리를 처리하기 용이한 형태로 변환하는 모듈.   

- **대안 계획 생성기**   
동일한 결과를 생성하는 다양한 대안 계획을 생성하는 모듈. 연산의 적용 순서 변경, 연산 방법 변경, 조인 순서 변경 등을 통해서 생성된다. 대안이 너무 많아지면 최적화를 수행하는 시간이 오래 걸릴 수 있기 때문에 상용 옵티마이저들은 대한 계획의 수를 제약하는 여러 방법들을 사용한다. -> 이런 현실적인 제약으로 인해 생성된 계획들 중 최적의 대한 계획이 포함되지 않을 수도 있다.    

- **비용 예측기**   
대안 계획 생성기에 의해서 생성된 계획의 비용을 예측하는 모듈. 정확한 통계정보를 필요로 한다.

&nbsp;


-----

&nbsp;

## 2.실행계획(Execution Plan)

SQL에서 요구한 사항을 처리하기 위한 절차와 방법. 동일한 쿼리에 대해 결과를 낼 수 있는 다양한 처리 방법(실행계획)이 존재할 수 있지만 각 처리 방법마다 실행 시간(성능)은 서로 다를 수 있다.   

&nbsp;

- 오라클의 실행계획 형태   
구성요소로는 조인순서, 조인기법, 액세스 기법, 최적화 정보, 연산 등이 있다.   

![SQL_242](https://user-images.githubusercontent.com/28701069/88663217-2ea0d780-d116-11ea-8495-dc2abffdd616.jpg)

- **조인순서**   
조인작업을 수행할 때 참조하는 테이블의 순서. 
- **조인기법**   
투 개의 테이블을 조인할 때 사용할 수 있는 방법. ex) NL Join, Hash Join, Sort Merge Join 등   
- **액세스 기법**   
하나의 테이블을 액세스할 때 사용할 수 있는 방법. ex) Index Scan, Full Table Scan 등   
- **최적화 정보**   
옵티마이저가 실행계획의 각 단계마다 예상되는 비용 사항을 표시한 것. (통계기반 예상치)    
ex) cost : 상대적인 비용 정보    
    card(cardinality) : 주어진 조건을 만족한 결과 집합 혹은 조인 조건을 만족한 결과 집합의 건수   
    bytes : 결과 집합이 차지하는 메모리 양을 바이트로 표시한 것.    
비용 사항이 표시되지 않았다면, 규칙기반 최적화 방식으로 실행계획을 생성한 것이다.   
- **연산**   
여러가지 조작을 통해서 원하는 결과를 얻어내는 일련의 작업. 조인기법, 액세스기법, 필터, 정렬, 집계, 뷰 등 다양한 종류가 존재한다.   

&nbsp;

-----

&nbsp;

## 3.SQL 처리 흐름도

SQL의 내부적인 처리 절차를 시각적으로 표현한 도표이다. (실행계획을 시각화)   

![SQL_243](https://user-images.githubusercontent.com/28701069/88665735-103cdb00-d11a-11ea-91cb-f80a931d0ec4.jpg)

```sql
SELECT ...
FROM TAB1 A, TAB2 B
WhERE A.KEY = B.KEY
AND A.COL1 = :condition1
AND B.COL2 = :condition2;
```

건수 또는 처리 결과 건수 등의 일량을 함께 표시해, 어느 부분에서 비효율이 발생하고  있는지에 대한 힌트를 얻을 수 있다.