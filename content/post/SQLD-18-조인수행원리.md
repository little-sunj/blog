---
title: "SQLD 18 조인수행원리"
date: 2020-07-29T22:01:28+09:00
categories:
- SQLD
- 2과목 SQL 기본 및 활용
tags:
- SQLD
keywords:
- SQLD
---

<!--more-->
# 조인 수행 원리

&nbsp;

## 1.NL Join

프로그래밍에서 사용하는 중첩된 반복문과 유사한 방식으로 조인을 수행. 주로 랜덤 액세스 방식.   
반복문의 외부에 있는 테이블을 선행 테이블 또는 외부 테이블 (Outer Table)이라고 하고, 반복문의 내부에 있는 테이블을 후행 테이블 또는 내부 테이블(Inner Join)이라고 한다.

```
 FOR 선행 테이블 읽음 → 외부 테이블(Outer Table)    
       FOR 후행 테이블 읽음 → 내부 테이블(Inner Table)    
 (선행 테이블과 후행 테이블 조인)   
```


1. 선행 테이블에서 주어진 조건을 만족하는 행을 찾음
2. 선행 테이블의 조인 키 값을 가지고 후행 테이블에서 조인 수행   
    a. 선행 테이블의 조인 키를 가지고 후행 테이블에 조인 키가 존재하는지 확인 → 조인시도   
    b. 후행 테이블 인덱스에 선행 테이블의 조인 키가 존재하는지 확인 → 없을시 필터링   
    c. 인덱스에서 추출한 레코드 식별자를 이용하여 후행 테이블을 액세스 → 인덱스 스캔   
    d. 후행 테이블에 주어진 조건까지 만족하면 해당 행을 추출버퍼에 넣음
3. 선행 테이블의 조건을 만족하는 모든 행에 대해 1번 작업 반복 수행  


> 결과행의 수가 적은(처리 주관 범위가 좁은) 테이블을 조인 순서상 선행 테이블로 선택하는 것이 전체 일량을 줄일 수 있다.

![SQL_250](https://user-images.githubusercontent.com/28701069/88803858-0da8b700-d1e8-11ea-850f-40fb864cae4a.jpg)

- **추출버퍼** : SQL문의 실행결과를 보관하는 버퍼로서 일정 크기를 설정하여 추출버퍼에 결과가 모두 차거나 더 이상 채울 것이 없으면 결과를 사용자에게 반환한다. 운반단위, Array Size, Prefetch Size라고도 한다.

&nbsp;

-----

&nbsp;

## 2.Sort Merge Join

조인 칼럼을 기준으로 데이터를 정렬하여 조인 수행. 주로 스캔 방식으로 데이터를 읽는다. NL Join에서 부담이 되던 넓음 범위의 데이터를 처리할 떄 이용되던 기법이다. 그러나 정렬할 데이터가 많은경우 임시 영역(디스크)을 사용하기 때문에 성능이 떨어질 수 있다.   
일반적으로는 CPU작업 위주로 처리하는 Hash Join이 성능상 유리하다. 그러나 Sort Merge Join은 동등 조인 뿐만 아니라 비동등 조인에 대해서도 작업이 가능하다는 장점이 있다.   

조인 칼럼의 인덱스를 사용하지 않기 때문에 인덱스가 존재하지 않을 경우에도 사용할 수 있는 기법니다.

![SQL_251](https://user-images.githubusercontent.com/28701069/88804866-780e2700-d1e9-11ea-84d2-41dd184ebf9f.jpg)


1. 선행 테이블에서 주어진 조건을 만족하는 행을 찾음   
2. 선행 테이블의 조인 키를 기준으로 정렬 작업을 수행   
3. 1 ~ 2번 작업을 선행 테이블의 조건을 만족하는 모든 행에 대해 반복 수행   
4. 후행 테이블에서 주어진 조건을 만족하는 행을 찾음   
5. 후행 테이블의 조인 키를 기준으로 정렬 작업을 수행   
6. 3 ~ 4번 작업을 후행 테이블의 조건을 만족하는 모든 행에 대해 반복 수행   
7. 정렬된 결과를 이용하여 조인을 수행하며 조인에 성공하면 추출버퍼에 넣음   

&nbsp;

-----

&nbsp;

## 3.Hash Join

해슁 기법을 이용하여 조인을 수행한다. 수행할 테이블의 조인 칼럼을 기준으로 해쉬 함수를 수행하여 서로 동일한 해쉬 값을 갖는 것들 사이에서 실제 값이 같은지를 비교하면서 조인을 수행한다.   
NL Join의 랜덤 액세스 문제점과 Sort Merge Join의 문제점인 정렬 작업의 부담을 해결 위한 대안으로 등장하였다.

조인 칼럼의 인덱스를 사용하지 않기 때문에, 조인 칼럼의 인덱스가 존재하지 않을 경우에도 사용 가능하다. 해쉬 함수를 이용하여 조인을 수행하기 때문에 '='로 수행하는 동등 조인에서만 사용할 수 있다. 

![SQL_252](https://user-images.githubusercontent.com/28701069/88805504-32059300-d1ea-11ea-87aa-d85b708313b5.jpg)

1. 선행 테이블에서 주어진 조건을 만족하는 행을 찾음 
2. 선행 테이블의 조인 키를 기준으로 해쉬 함수를 적용하여 해쉬 테이블을 생성 → 조인 칼럼과 SELECT 절에서 필요로 하는 칼럼도 함께 저장됨 
3. 1 ~ 2 번 작업을 선행 테이블의 조건을 만족하는 모든 행에 대해 반복 수행 
4. 후행 테이블에서 주어진 조건을 만족하는 행을 찾음 
5. 후행 테이블의 조인 키를 기준으로 해쉬 함수를 적용하여 해당 버킷을 찾음 → 조인 키를 이용해서 실제 조인될 데이터를 찾음 
6. 조인에 성공하면 추출버퍼에 넣음 
7. 3 ~5번 작업을 후행 테이블의 조건을 만족하는 모든 행에 대해서 반복 수행

Hash Join은 조인 작업을 수행하기 위해 해쉬 테이블을 메모리에 생성해야한다. 생성된 해쉬 테이블의 크기가 메모리에 적재할 수 있는 크기보다 더 커지면 임시 영역 (디스크)에 해쉬 테이블은 저장한다. 그렇기 때문에 Hash Join시 결과 행의 수가 적은 테이블을 선행 테이블로 사용하는 것이 좋다. 선행 테이블의 결과를 완전히 메모리에 저장할 수 있다면 임시 영역에 저장하는 작업이 발생하지 않기 때문이다.   

선행 테이블을 이용하여 먼저 해쉬 테이블을 생성한다고 해서 선행 테이블을 Build Input이라고도 하며,   
후행 테이블은 만들어진 해쉬 테이블에 대해 해쉬 값을 존재여부를 검사한다고 해서 Prove Input이라고도 한다.